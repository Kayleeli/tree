<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Pro Gesture Tree - HUD Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        :root { --gold: #ffd700; --panel-bg: rgba(0, 0, 0, 0.6); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', system-ui, sans-serif; color: white; touch-action: none; }
        canvas { display: block; }
        
        #ui-layer { 
            position: absolute; 
            inset: 0; 
            pointer-events: none; 
            z-index: 10; 
            display: flex; 
            flex-direction: column; 
            justify-content: space-between; 
            padding: 20px;
        }

        .panel { 
            pointer-events: auto; 
            backdrop-filter: blur(10px); 
            padding: 15px; 
            border-radius: 12px; 
        }

        #legend { 
            width: fit-content; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            border-left: 2px solid var(--gold);
        }

        h1 { margin: 0 0 12px 0; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; color: var(--gold); opacity: 0.8; }
        
        .gesture-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .gesture-item { font-size: 10px; opacity: 0.3; transition: 0.3s; border-left: 1px solid rgba(255,255,255,0.2); padding-left: 8px; }
        .gesture-item span:first-child { font-weight: 800; display: block; color: var(--gold); font-size: 9px; margin-bottom: 2px; }
        .gesture-item.active { opacity: 1; border-left-color: var(--gold); transform: translateX(5px); }

        #video-container { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 100px; 
            height: 130px; 
            border-radius: 12px; 
            overflow: hidden; 
            transform: scaleX(-1); 
            border: 1px solid rgba(255,255,255,0.2); 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        @media (min-width: 768px) {
            #video-container { width: 200px; height: 150px; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="legend" class="panel">
        <h1>Tree Gesture Engine</h1>
        <div class="gesture-grid">
            <div id="g-vsign" class="gesture-item"><span>"V" Sign</span>Supernova</div>
            <div id="g-fist" class="gesture-item"><span>Fist</span>Reset Tree</div>
            <div id="g-open" class="gesture-item"><span>Open Palm</span>Hue & Disperse</div>
            <div id="g-heart" class="gesture-item"><span>2 Hands</span>Heart Mode</div>
        </div>
    </div>
    
    <div id="video-container"><video id="webcam" playsinline></video></div>
</div>

<script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const isMobile = window.innerWidth < 768;
const TREE_COUNT = isMobile ? 6000 : 9000;
const ORN_COUNT = isMobile ? 400 : 600;
const STAR_COUNT = 200;
const TOTAL = TREE_COUNT + ORN_COUNT + STAR_COUNT;

const STATE = { TREE: 0, DISPERSE: 1, HEART: 2 };
let currentState = STATE.TREE;
let rotationTarget = { x: 0, y: 0 };
let explodeFactor = 0;
let hueBase = 0.35;

const vertexShader = `
    uniform float uTime;
    uniform float uPixelRatio;
    attribute float aSize;
    attribute float aGlow;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vGlow;
    void main() {
        vColor = color;
        vGlow = aGlow;
        vec3 p = position;
        p.x += sin(uTime + position.y) * 0.02;
        p.z += cos(uTime + position.x) * 0.02;
        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
        gl_PointSize = aSize * uPixelRatio * (45.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fragmentShader = `
    varying vec3 vColor;
    varying float vGlow;
    void main() {
        float d = distance(gl_PointCoord, vec2(0.5));
        float alpha = exp(-d * d * 9.0);
        gl_FragColor = vec4(vColor * vGlow, alpha);
    }
`;

const getTreePoint = (i) => {
    const h = Math.random() * 16;
    const ratio = h / 16;
    const radius = (1 - ratio) * 6.5 * Math.sqrt(Math.random());
    const angle = i * 0.12;
    return { x: Math.cos(angle) * radius, y: h - 8, z: Math.sin(angle) * radius };
};

const getStarPoint = () => {
    const r = Math.random() * 0.7;
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    return { x: r * Math.sin(phi) * Math.cos(theta), y: 8.5 + r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
};

const getHeartPoint = () => {
    const t = Math.random() * Math.PI * 2;
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    const z = (Math.random() - 0.5) * 8;
    return { x: x * 0.45, y: y * 0.45, z: z * 0.3 };
};

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = isMobile ? 60 : 45;

const renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
composer.addPass(bloomPass);

const geometry = new THREE.BufferGeometry();
const posArr = new Float32Array(TOTAL * 3);
const treeTgt = new Float32Array(TOTAL * 3);
const heartTgt = new Float32Array(TOTAL * 3);
const dispTgt = new Float32Array(TOTAL * 3);
const explodeDirs = new Float32Array(TOTAL * 3);
const colArr = new Float32Array(TOTAL * 3);
const sizeArr = new Float32Array(TOTAL);
const glowArr = new Float32Array(TOTAL);

const ornamentPalettes = [0xff0055, 0x00ffff, 0xffd700, 0xffffff, 0x7f00ff];

for (let i = 0; i < TOTAL; i++) {
    let tp;
    const colorObj = new THREE.Color();
    if (i < TREE_COUNT) {
        tp = getTreePoint(i);
        colorObj.setHSL(hueBase, 1.0, 0.4);
        sizeArr[i] = 3.0 + Math.random() * 2.0;
        glowArr[i] = 1.0;
    } else if (i < TREE_COUNT + ORN_COUNT) {
        tp = getTreePoint(i);
        colorObj.set(ornamentPalettes[Math.floor(Math.random() * ornamentPalettes.length)]);
        sizeArr[i] = 4.5 + Math.random() * 2.0;
        glowArr[i] = 2.5;
    } else {
        tp = getStarPoint();
        colorObj.set(0xfff000);
        sizeArr[i] = 6.0;
        glowArr[i] = 2.0;
    }
    treeTgt.set([tp.x, tp.y, tp.z], i * 3);
    colArr.set([colorObj.r, colorObj.g, colorObj.b], i * 3);
    const hp = getHeartPoint();
    heartTgt.set([hp.x, hp.y, hp.z], i * 3);
    dispTgt.set([(Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80], i * 3);
    const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(60);
    explodeDirs.set([dir.x, dir.y, dir.z], i * 3);
}

geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
geometry.setAttribute('aSize', new THREE.BufferAttribute(sizeArr, 1));
geometry.setAttribute('aGlow', new THREE.BufferAttribute(glowArr, 1));

const material = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPixelRatio: { value: renderer.getPixelRatio() } },
    vertexShader, fragmentShader, transparent: true, blending: THREE.NormalBlending, depthWrite: false
});
const points = new THREE.Points(geometry, material);
scene.add(points);

const video = document.getElementById('webcam');
const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ maxNumHands: 2, modelComplexity: isMobile ? 0 : 1, minDetectionConfidence: 0.6 });

hands.onResults((res) => {
    document.querySelectorAll('.gesture-item').forEach(el => el.classList.remove('active'));
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const h = res.multiHandLandmarks[0];
        
        rotationTarget.y = (h[9].x - 0.5) * (isMobile ? 2.5 : 4);
        rotationTarget.x = (h[9].y - 0.5) * (isMobile ? 1.2 : 2);
        
        if (res.multiHandLandmarks.length === 2) {
            currentState = STATE.HEART;
            document.getElementById('g-heart').classList.add('active');
        } else {
            const isV = h[8].y < h[6].y && h[12].y < h[10].y && h[16].y > h[14].y;
            const isFist = h[8].y > h[5].y && h[12].y > h[9].y;

            if (isV) {
                explodeFactor = 1.0;
                document.getElementById('g-vsign').classList.add('active');
            } else if (isFist) {
                currentState = STATE.TREE;
                document.getElementById('g-fist').classList.add('active');
            } else {
                currentState = STATE.DISPERSE;
                hueBase = 1.0 - h[9].y; 
                document.getElementById('g-open').classList.add('active');
            }
        }
    }
});

new Camera(video, { 
    onFrame: async () => await hands.send({image: video}), 
    width: 480, height: 640, 
    facingMode: 'user' 
}).start();

function animate(t) {
    requestAnimationFrame(animate);
    material.uniforms.uTime.value = t * 0.001;
    explodeFactor *= 0.92;
    
    points.rotation.y += (rotationTarget.y - points.rotation.y) * 0.05;
    points.rotation.x += (rotationTarget.x - points.rotation.x) * 0.05;

    const pos = geometry.attributes.position.array;
    const col = geometry.attributes.color.array;
    const target = currentState === STATE.HEART ? heartTgt : (currentState === STATE.DISPERSE ? dispTgt : treeTgt);
    const mobileYOffset = isMobile ? -4 : 0;

    for (let i = 0; i < TOTAL; i++) {
        const ix = i * 3;
        
        if (i < TREE_COUNT) {
            const foli = new THREE.Color().setHSL(hueBase, 1, 0.4);
            col[ix] += (foli.r - col[ix]) * 0.1;
            col[ix+1] += (foli.g - col[ix+1]) * 0.1;
            col[ix+2] += (foli.b - col[ix+2]) * 0.1;
        }

        let tx = target[ix];
        let ty = target[ix+1] + mobileYOffset;
        let tz = target[ix+2];
        
        if (explodeFactor > 0.01) {
            tx += explodeDirs[ix] * explodeFactor;
            ty += explodeDirs[ix+1] * explodeFactor;
            tz += explodeDirs[ix+2] * explodeFactor;
        }

        pos[ix] += (tx - pos[ix]) * 0.08;
        pos[ix+1] += (ty - pos[ix+1]) * 0.08;
        pos[ix+2] += (tz - pos[ix+2]) * 0.08;
    }
    
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    composer.render();
}
animate(0);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    material.uniforms.uPixelRatio.value = renderer.getPixelRatio();
});
</script>
</body>
</html>
