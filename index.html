<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Pro Gesture Tree - Mobile Optimized</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        :root { --gold: #ffd700; --panel-bg: rgba(0, 0, 0, 0.8); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', system-ui, -apple-system, sans-serif; color: white; touch-action: none; }
        canvas { display: block; }
        
        #ui-layer { 
            position: absolute; 
            inset: 0; 
            pointer-events: none; 
            z-index: 10; 
            display: flex; 
            flex-direction: column; 
            padding: 15px;
            gap: 10px;
        }

        .panel { 
            pointer-events: auto; 
            background: var(--panel-bg); 
            backdrop-filter: blur(15px); 
            padding: 15px; 
            border-radius: 12px; 
            border: 1px solid rgba(255, 255, 255, 0.1); 
        }

        #legend { width: 100%; max-width: 240px; }
        #controls { width: 100%; max-width: 240px; }

        h1 { margin: 0 0 10px 0; font-size: 10px; letter-spacing: 2px; text-transform: uppercase; color: var(--gold); border-bottom: 1px solid rgba(255,215,0,0.3); padding-bottom: 5px; }
        
        .gesture-item { margin: 8px 0; font-size: 10px; display: flex; flex-direction: column; opacity: 0.3; transition: 0.3s; }
        .gesture-item span:first-child { font-weight: 800; text-transform: uppercase; font-size: 9px; color: var(--gold); }
        .gesture-item.active { opacity: 1; transform: translateX(5px); }
        
        .control-group { margin-bottom: 10px; }
        label { display: block; font-size: 9px; text-transform: uppercase; margin-bottom: 5px; color: #aaa; }
        
        /* Better sliders for mobile thumbs */
        input[type=range] { width: 100%; height: 20px; cursor: pointer; accent-color: var(--gold); }

        #video-container { 
            position: absolute; 
            bottom: 20px; 
            right: 20px; 
            width: 100px; 
            height: 75px; 
            border-radius: 8px; 
            overflow: hidden; 
            transform: scaleX(-1); 
            border: 1px solid rgba(255,255,255,0.2); 
        }
        video { width: 100%; height: 100%; object-fit: cover; }

        @media (min-width: 768px) {
            #ui-layer { flex-direction: row; justify-content: space-between; }
            #video-container { width: 200px; height: 150px; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="legend" class="panel">
        <h1>Gesture Engine</h1>
        <div id="g-vsign" class="gesture-item"><span>"V" Sign</span><span>Supernova</span></div>
        <div id="g-fist" class="gesture-item"><span>Closed Fist</span><span>Return to Tree</span></div>
        <div id="g-open" class="gesture-item"><span>Open Palm</span><span>Hue / Disperse</span></div>
        <div id="g-heart" class="gesture-item"><span>Two Hands</span><span>Volumetric Heart</span></div>
        <div class="control-group" style="margin-top:10px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
            <label>Master Glow</label>
            <input type="range" id="glowSlider" min="0" max="3" step="0.1" value="1.5">
        </div>
    </div>
    <div id="controls" class="panel">
        <h1>Calibration</h1>
        <div class="control-group">
            <label>Foliage Hue</label>
            <input type="range" id="hueSlider" min="0" max="1" step="0.01" value="0.35">
        </div>
    </div>
    <div id="video-container"><video id="webcam" playsinline></video></div>
</div>

<script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const isMobile = window.innerWidth < 768;
const TREE_COUNT = isMobile ? 5000 : 9000;
const ORN_COUNT = isMobile ? 300 : 600;
const STAR_COUNT = 200;
const TOTAL = TREE_COUNT + ORN_COUNT + STAR_COUNT;

const STATE = { TREE: 0, DISPERSE: 1, HEART: 2 };
let currentState = STATE.TREE;
let rotationTarget = { x: 0, y: 0 };
let explodeFactor = 0;
let hueBase = 0.35;

const vertexShader = `
    uniform float uTime;
    uniform float uPixelRatio;
    attribute float aSize;
    attribute float aGlow;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vGlow;
    void main() {
        vColor = color;
        vGlow = aGlow;
        vec3 p = position;
        p.x += sin(uTime + position.y) * 0.03;
        p.z += cos(uTime + position.x) * 0.03;
        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
        // Mobile-aware point sizing
        gl_PointSize = aSize * uPixelRatio * (40.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fragmentShader = `
    varying vec3 vColor;
    varying float vGlow;
    void main() {
        float d = distance(gl_PointCoord, vec2(0.5));
        float alpha = exp(-d * d * 8.0);
        gl_FragColor = vec4(vColor * vGlow, alpha);
    }
`;

// Point generators remain same
const getTreePoint = (i) => {
    const h = Math.random() * 16;
    const ratio = h / 16;
    const radius = (1 - ratio) * 6.5 * Math.sqrt(Math.random());
    const angle = i * 0.12;
    return { x: Math.cos(angle) * radius, y: h - 8, z: Math.sin(angle) * radius };
};

const getStarPoint = () => {
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const r = Math.random() * 0.7;
    return { x: r * Math.sin(phi) * Math.cos(theta), y: 8.5 + r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
};

const getHeartPoint = () => {
    const t = Math.random() * Math.PI * 2;
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    const zScale = Math.sqrt(Math.max(0, 1 - Math.pow(Math.random()*2 - 1, 2))) * 8;
    const z = (Math.random() - 0.5) * zScale;
    return { x: x * 0.4, y: y * 0.4, z: z * 0.4 };
};

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = isMobile ? 55 : 45;

const renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
document.body.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
composer.addPass(bloomPass);

document.getElementById('glowSlider').oninput = (e) => bloomPass.strength = parseFloat(e.target.value);
document.getElementById('hueSlider').oninput = (e) => hueBase = parseFloat(e.target.value);

const geometry = new THREE.BufferGeometry();
const posArr = new Float32Array(TOTAL * 3);
const treeTgt = new Float32Array(TOTAL * 3);
const heartTgt = new Float32Array(TOTAL * 3);
const dispTgt = new Float32Array(TOTAL * 3);
const explodeDirs = new Float32Array(TOTAL * 3);
const colArr = new Float32Array(TOTAL * 3);
const sizeArr = new Float32Array(TOTAL);
const glowArr = new Float32Array(TOTAL);

const ornamentPalettes = [0xff0055, 0x00ffff, 0xffd700, 0xffffff, 0x7f00ff];

for (let i = 0; i < TOTAL; i++) {
    let tp;
    const colorObj = new THREE.Color();
    if (i < TREE_COUNT) {
        tp = getTreePoint(i);
        colorObj.setHSL(hueBase, 1.0, 0.4);
        sizeArr[i] = 3.0 + Math.random() * 2.0;
        glowArr[i] = 1.0;
    } else if (i < TREE_COUNT + ORN_COUNT) {
        tp = getTreePoint(i);
        colorObj.set(ornamentPalettes[Math.floor(Math.random() * ornamentPalettes.length)]);
        sizeArr[i] = 4.0 + Math.random() * 2.5;
        glowArr[i] = 2.5;
    } else {
        tp = getStarPoint();
        colorObj.set(0xfff000);
        sizeArr[i] = 6.0;
        glowArr[i] = 2.0;
    }
    treeTgt.set([tp.x, tp.y, tp.z], i * 3);
    colArr.set([colorObj.r, colorObj.g, colorObj.b], i * 3);
    const hp = getHeartPoint();
    heartTgt.set([hp.x, hp.y, hp.z], i * 3);
    dispTgt.set([(Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80], i * 3);
    const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(50);
    explodeDirs.set([dir.x, dir.y, dir.z], i * 3);
}

geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
geometry.setAttribute('aSize', new THREE.BufferAttribute(sizeArr, 1));
geometry.setAttribute('aGlow', new THREE.BufferAttribute(glowArr, 1));

const material = new THREE.ShaderMaterial({
    uniforms: { 
        uTime: { value: 0 }, 
        uPixelRatio: { value: renderer.getPixelRatio() } 
    },
    vertexShader, fragmentShader, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
});
const points = new THREE.Points(geometry, material);
scene.add(points);

const video = document.getElementById('webcam');
const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ 
    maxNumHands: 2, 
    modelComplexity: isMobile ? 0 : 1, // Lower complexity for mobile
    minDetectionConfidence: 0.6 
});

hands.onResults((res) => {
    document.querySelectorAll('.gesture-item').forEach(el => el.classList.remove('active'));
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const h = res.multiHandLandmarks[0];
        rotationTarget.y = (h[9].x - 0.5) * 3;
        rotationTarget.x = (h[9].y - 0.5) * 1.5;
        
        if (res.multiHandLandmarks.length === 2) {
            currentState = STATE.HEART;
            document.getElementById('g-heart').classList.add('active');
        } else {
            const isV = h[8].y < h[6].y && h[12].y < h[10].y && h[16].y > h[14].y;
            const isFist = h[8].y > h[5].y && h[12].y > h[9].y;
            if (isV) {
                explodeFactor = 1.0;
                document.getElementById('g-vsign').classList.add('active');
            } else if (isFist) {
                currentState = STATE.TREE;
                document.getElementById('g-fist').classList.add('active');
            } else {
                currentState = STATE.DISPERSE;
                hueBase = 1.0 - h[9].y;
                document.getElementById('hueSlider').value = hueBase;
                document.getElementById('g-open').classList.add('active');
            }
        }
    }
});

new Camera(video, { 
    onFrame: async () => await hands.send({image: video}), 
    width: 480, height: 360, 
    facingMode: 'user' 
}).start();

function animate(t) {
    requestAnimationFrame(animate);
    material.uniforms.uTime.value = t * 0.001;
    explodeFactor *= 0.93;
    points.rotation.y += (rotationTarget.y - points.rotation.y) * 0.05;
    points.rotation.x += (rotationTarget.x - points.rotation.x) * 0.05;

    const pos = geometry.attributes.position.array;
    const col = geometry.attributes.color.array;
    const target = currentState === STATE.HEART ? heartTgt : (currentState === STATE.DISPERSE ? dispTgt : treeTgt);

    for (let i = 0; i < TOTAL; i++) {
        const ix = i * 3;
        if (i < TREE_COUNT) {
            const foli = new THREE.Color().setHSL(hueBase, 1, 0.4);
            col[ix] += (foli.r - col[ix]) * 0.1;
            col[ix+1] += (foli.g - col[ix+1]) * 0.1;
            col[ix+2] += (foli.b - col[ix+2]) * 0.1;
        }
        let tx = target[ix] + (explodeFactor > 0 ? explodeDirs[ix] * explodeFactor : 0);
        let ty = target[ix+1] + (explodeFactor > 0 ? explodeDirs[ix+1] * explodeFactor : 0);
        let tz = target[ix+2] + (explodeFactor > 0 ? explodeDirs[ix+2] * explodeFactor : 0);
        pos[ix] += (tx - pos[ix]) * 0.1;
        pos[ix+1] += (ty - pos[ix+1]) * 0.1;
        pos[ix+2] += (tz - pos[ix+2]) * 0.1;
    }
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    composer.render();
}
animate(0);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
