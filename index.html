<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Pro Gesture Tree - Fixed Heart Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; z-index: 10; }
        .panel { pointer-events: auto; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(20px); padding: 20px; border-radius: 12px; border: 1px solid rgba(255, 255, 255, 0.1); }
        #legend { position: absolute; top: 20px; left: 20px; width: 240px; }
        #controls { position: absolute; top: 20px; right: 20px; width: 200px; }
        h1 { margin: 0 0 15px 0; font-size: 11px; letter-spacing: 2px; text-transform: uppercase; color: #ffd700; border-bottom: 1px solid rgba(255,215,0,0.3); padding-bottom: 8px; }
        .gesture-item { margin: 10px 0; font-size: 10px; display: flex; flex-direction: column; gap: 2px; opacity: 0.3; transition: 0.3s; }
        .gesture-item span:first-child { font-weight: 800; text-transform: uppercase; font-size: 9px; color: #ffd700; }
        .gesture-item.active { opacity: 1; transform: translateX(5px); }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 9px; text-transform: uppercase; margin-bottom: 5px; color: #aaa; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #ffd700; }
        #video-container { position: absolute; bottom: 20px; right: 20px; width: 260; height: 195px; border-radius: 10px; overflow: hidden; transform: scaleX(-1); border: 1px solid rgba(255,255,255,0.1); }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="legend" class="panel">
        <h1>Tree Gesture Engine</h1>
        <div id="g-vsign" class="gesture-item"><span>"V" Sign</span><span>Supernova Explosion</span></div>
        <div id="g-fist" class="gesture-item"><span>Closed Fist</span><span>Return to Tree</span></div>
        <div id="g-open" class="gesture-item"><span>Open Palm</span><span>Hue Shift / Disperse</span></div>
        <div id="g-heart" class="gesture-item"><span>Two Hands</span><span>Volumetric Heart</span></div>
        <hr style="border:0; border-top:1px solid rgba(255,255,255,0.1); margin: 15px 0;">
        <div class="control-group">
            <label>Master Glow</label>
            <input type="range" id="glowSlider" min="0" max="3" step="0.1" value="1.5">
        </div>
    </div>
    <div id="controls" class="panel">
        <h1>Calibration</h1>
        <div class="control-group">
            <label>Foliage Hue</label>
            <input type="range" id="hueSlider" min="0" max="1" step="0.01" value="0.35">
        </div>
    </div>
    <div id="video-container"><video id="webcam" playsinline></video></div>
</div>

<script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

<script type="module">
import * as THREE from "three";
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

const TREE_COUNT = 9000;
const ORN_COUNT = 600;
const STAR_COUNT = 400;
const TOTAL = TREE_COUNT + ORN_COUNT + STAR_COUNT;

const STATE = { TREE: 0, DISPERSE: 1, HEART: 2 };
let currentState = STATE.TREE;
let rotationTarget = { x: 0, y: 0 };
let explodeFactor = 0;
let hueBase = 0.35;

const vertexShader = `
    uniform float uTime;
    attribute float aSize;
    attribute float aGlow;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vGlow;
    void main() {
        vColor = color;
        vGlow = aGlow;

        vec3 p = position;
        p.x += sin(uTime + position.y) * 0.03;
        p.z += cos(uTime + position.x) * 0.03;

        vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
        gl_PointSize = aSize * (45.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const fragmentShader = `
    varying vec3 vColor;
    varying float vGlow;
    void main() {
        float d = distance(gl_PointCoord, vec2(0.5));
        float alpha = exp(-d * d * 8.0);
        gl_FragColor = vec4(vColor * vGlow, alpha);
    }
`;

const getTreePoint = (i) => {
    const h = Math.random() * 16;
    const ratio = h / 16;
    const radius = (1 - ratio) * 6.5 * Math.sqrt(Math.random());
    const angle = i * 0.12;
    return { x: Math.cos(angle) * radius, y: h - 8, z: Math.sin(angle) * radius };
};

const getStarPoint = () => {
    const phi = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const r = Math.random() * 0.7;
    return { x: r * Math.sin(phi) * Math.cos(theta), y: 8.5 + r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
};

const getHeartPoint = () => {
    const t = Math.random() * Math.PI * 2;
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
    const zScale = Math.sqrt(Math.max(0, 1 - Math.pow(Math.random()*2 - 1, 2))) * 8;
    const z = (Math.random() - 0.5) * zScale;
    return { x: x * 0.5, y: y * 0.5, z: z * 0.5 };
};

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 45;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
composer.addPass(bloomPass);

document.getElementById('glowSlider').oninput = (e) => bloomPass.strength = parseFloat(e.target.value);
document.getElementById('hueSlider').oninput = (e) => hueBase = parseFloat(e.target.value);

const geometry = new THREE.BufferGeometry();
const posArr = new Float32Array(TOTAL * 3);
const treeTgt = new Float32Array(TOTAL * 3);
const heartTgt = new Float32Array(TOTAL * 3);
const dispTgt = new Float32Array(TOTAL * 3);
const explodeDirs = new Float32Array(TOTAL * 3);
const colArr = new Float32Array(TOTAL * 3);
const sizeArr = new Float32Array(TOTAL);
const glowArr = new Float32Array(TOTAL);

const ornamentPalettes = [0xff0055, 0x00ffff, 0xffd700, 0xffffff, 0x7f00ff];

for (let i = 0; i < TOTAL; i++) {
    let tp;
    const colorObj = new THREE.Color();
    
    if (i < TREE_COUNT) {
        tp = getTreePoint(i);
        colorObj.setHSL(hueBase, 1.0, 0.4);
        sizeArr[i] = 3.5 + Math.random() * 2.0;
        glowArr[i] = 1.0;
    } else if (i < TREE_COUNT + ORN_COUNT) {
        tp = getTreePoint(i);
        colorObj.set(ornamentPalettes[Math.floor(Math.random() * ornamentPalettes.length)]);
        sizeArr[i] = 4.2 + Math.random() * 2.5;
        glowArr[i] = 2.6 + Math.random() * 1.2;
    } else {
        tp = getStarPoint();
        colorObj.set(0xfff000);
        sizeArr[i] = 5.0;
        glowArr[i] = 2.0;
    }

    treeTgt.set([tp.x, tp.y, tp.z], i * 3);
    colArr.set([colorObj.r, colorObj.g, colorObj.b], i * 3);
    
    const hp = getHeartPoint();
    heartTgt.set([hp.x, hp.y, hp.z], i * 3);
    
    dispTgt.set([(Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80], i * 3);
    const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(50);
    explodeDirs.set([dir.x, dir.y, dir.z], i * 3);
}

geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
geometry.setAttribute('aSize', new THREE.BufferAttribute(sizeArr, 1));
geometry.setAttribute('aGlow', new THREE.BufferAttribute(glowArr, 1));

const points = new THREE.Points(geometry, new THREE.ShaderMaterial({
    vertexShader, fragmentShader, transparent: true, blending: THREE.NormalBlending, depthWrite: false
}));
scene.add(points);

const video = document.getElementById('webcam');
const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7 });

hands.onResults((res) => {
    document.querySelectorAll('.gesture-item').forEach(el => el.classList.remove('active'));
    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
        const h = res.multiHandLandmarks[0];
        rotationTarget.y = (h[9].x - 0.5) * 4;
        rotationTarget.x = (h[9].y - 0.5) * 2;
        if (res.multiHandLandmarks.length === 2) {
            currentState = STATE.HEART;
            document.getElementById('g-heart').classList.add('active');
        } else {
            const isV = h[8].y < h[6].y && h[12].y < h[10].y && h[16].y > h[14].y;
            const isFist = h[8].y > h[5].y && h[12].y > h[9].y;
            if (isV) {
                explodeFactor = 1.0;
                document.getElementById('g-vsign').classList.add('active');
            } else if (isFist) {
                currentState = STATE.TREE;
                document.getElementById('g-fist').classList.add('active');
            } else {
                currentState = STATE.DISPERSE;
                hueBase = 1.0 - h[9].y;
                document.getElementById('hueSlider').value = hueBase;
                document.getElementById('g-open').classList.add('active');
            }
        }
    }
});

new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 }).start();

function animate() {
    requestAnimationFrame(animate);
    explodeFactor *= 0.93;
    points.rotation.y += (rotationTarget.y - points.rotation.y) * 0.05;
    points.rotation.x += (rotationTarget.x - points.rotation.x) * 0.05;

    const pos = geometry.attributes.position.array;
    const col = geometry.attributes.color.array;
    const target = currentState === STATE.HEART ? heartTgt : (currentState === STATE.DISPERSE ? dispTgt : treeTgt);

    for (let i = 0; i < TOTAL; i++) {
        const ix = i * 3;
        if (i < TREE_COUNT) {
            const foli = new THREE.Color().setHSL(hueBase, 1, 0.4);
            col[ix] += (foli.r - col[ix]) * 0.1;
            col[ix+1] += (foli.g - col[ix+1]) * 0.1;
            col[ix+2] += (foli.b - col[ix+2]) * 0.1;
        }
        let tx = target[ix] + (explodeFactor > 0 ? explodeDirs[ix] * explodeFactor : 0);
        let ty = target[ix+1] + (explodeFactor > 0 ? explodeDirs[ix+1] * explodeFactor : 0);
        let tz = target[ix+2] + (explodeFactor > 0 ? explodeDirs[ix+2] * explodeFactor : 0);
        pos[ix] += (tx - pos[ix]) * 0.08;
        pos[ix+1] += (ty - pos[ix+1]) * 0.08;
        pos[ix+2] += (tz - pos[ix+2]) * 0.08;
    }
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    composer.render();
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
